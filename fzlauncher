#!/usr/bin/env python3
from __future__ import annotations

import json
import os
import shlex
import subprocess
import sys

from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
from pathlib import Path

APP_DIRS = [
    Path("/usr/share/applications"),
    Path(os.path.expanduser("~/.local/share/applications")),
]

CACHE_DIR = Path(os.path.expanduser("~/.cache/fzlauncher"))
CACHE_FILE = CACHE_DIR / "apps.json"
STAMP_FILE = CACHE_DIR / "stamp.json"


def strip_field_codes(cmd: str) -> str:
    idx = cmd.find(" %")
    return cmd if idx == -1 else cmd[:idx]


def fast_parse(path: Path) -> dict[str, str] | None:
    name = exec_ = None
    no_display = False
    is_desktop_entry = False

    try:
        with path.open("r", encoding="utf-8", errors="ignore") as fh:
            for line in fh:
                line = line.strip()
                if line == "[Desktop Entry]":
                    is_desktop_entry = True
                    continue

                if not is_desktop_entry:
                    continue

                if line.startswith("NoDisplay=true"):
                    no_display = True
                    break
                elif line.startswith("Name=") and name is None:
                    name = line[5:]
                elif line.startswith("Exec=") and exec_ is None:
                    exec_ = line[5:]

    except Exception as e:
        if os.getenv("DEBUG"):
            print(f"Parse error in {path}: {e}", file=sys.stderr)
        return None

    if not all([is_desktop_entry, name, exec_]) or no_display:
        return None

    # fucking type checking
    assert name is not None and exec_ is not None
    return {"name": name, "exec": strip_field_codes(exec_)}


@lru_cache(maxsize=1)
def get_desktop_files_cached() -> tuple[Path, ...]:
    files: list[Path] = []
    for path in APP_DIRS:
        if path.exists():
            files.extend(path.rglob("*.desktop"))
    return tuple(files)


def cache_still_valid() -> bool:
    if not (CACHE_FILE.exists() and STAMP_FILE.exists()):
        return False

    try:
        stamp_data = json.loads(STAMP_FILE.read_text())
        latest_mtime = max(p.stat().st_mtime_ns for p in APP_DIRS if p.exists())

        return stamp_data.get("source_mtime_ns") == latest_mtime
    except Exception:
        return False


def write_cache(apps: dict[str, str]) -> None:
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    CACHE_FILE.write_text(json.dumps(apps, ensure_ascii=False))

    try:
        latest_mtime = max(p.stat().st_mtime_ns for p in APP_DIRS if p.exists())
        stamp = {"source_mtime_ns": latest_mtime}
        STAMP_FILE.write_text(json.dumps(stamp))
    except Exception as e:
        if os.getenv("DEBUG"):
            print(f"Could not write cache stamp: {e}", file=sys.stderr)


def build_cache_parallel() -> dict[str, str]:
    files = get_desktop_files_cached()
    max_workers = min(32, (os.cpu_count() or 1) * 2)

    apps = {}
    with ThreadPoolExecutor(max_workers=max_workers) as pool:
        future_to_path = {pool.submit(fast_parse, path): path for path in files if path.is_file()}

        for future in as_completed(future_to_path):
            try:
                if data := future.result():
                    if data["name"] not in apps:
                        apps[data["name"]] = data["exec"]
            except Exception:
                continue
    return apps


class AppCache:
    def __init__(self):
        self._cache: dict[str, str] | None = None

    def get(self) -> dict[str, str]:
        if self._cache is None:
            self._cache = self._build_app_cache()
        return self._cache

    def _build_app_cache(self) -> dict[str, str]:
        if cache_still_valid():
            try:
                return json.loads(CACHE_FILE.read_text())
            except Exception:
                pass

        apps = build_cache_parallel()
        write_cache(apps)
        return apps

    def invalidate(self) -> None:
        self._cache = None


def select_with_fzf(apps: dict[str, str]) -> str | None:
    app_names = "\n".join(sorted(apps.keys()))

    fzf_cmd = """
[ -f ~/.cache/wal/colors-fzf.sh ] && . ~/.cache/wal/colors-fzf.sh

fzf --margin=0 --padding=0 --prompt='Launch: '
"""
    try:
        proc = subprocess.run(
            ["bash", "-c", fzf_cmd],
            input=app_names,
            capture_output=True,
            text=True,
            check=True,
        )
        return proc.stdout.strip() or None
    except subprocess.CalledProcessError as e:
        if e.returncode != 130:
            print(f"fzf failed: {e}", file=sys.stderr)
        return None


def _should_run_in_terminal(desktop_path: Path) -> bool:
    try:
        with desktop_path.open("r", encoding="utf-8", errors="ignore") as fh:
            for line in fh:
                if line.strip() == "Terminal=true":
                    return True
    except Exception:
        pass
    return False

def launch(name: str, apps: dict[str, str]) -> None:
    if name not in apps:
        print(f"Application '{name}' not found in cache.", file=sys.stderr)
        return

    cmd = apps[name]

    desktop_file: Path | None = None
    for app_dir in APP_DIRS:
        for path in app_dir.rglob("*.desktop"):
            data = fast_parse(path)
            if data and data["name"] == name:
                desktop_file = path
                break
        if desktop_file:
            break

    if desktop_file and _should_run_in_terminal(desktop_file):
        term = shlex.split(os.getenv("TERMINAL") or "xterm -e")
        args = term + shlex.split(cmd)
    else:
        args = shlex.split(cmd)

    try:
        subprocess.Popen(
            args,
            start_new_session=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except Exception as e:
        print(f"Failed to launch '{name}' with command '{' '.join(args)}': {e}", file=sys.stderr)


def main() -> None:
    app_cache = AppCache()
    apps = app_cache.get()

    if not apps:
        print("No applications found. Scanned directories:", file=sys.stderr)
        for app_dir in APP_DIRS:
            print(f"- {app_dir} (exists: {app_dir.exists()})", file=sys.stderr)
        return

    if selected_app := select_with_fzf(apps):
        launch(selected_app, apps)


if __name__ == "__main__":
    main()
